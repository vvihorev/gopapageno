package generator

import (
	"fmt"
	"log"
	"os"
	"path"
)

const (
	GeneratedLexerFilename  = "lexer.pg.go"
	GeneratedParserFilename = "parser.pg.go"
	GeneratedMainFilename   = "main.pg.go"
)

type Options struct {
	LexerDescriptionFilename  string
	ParserDescriptionFilename string
	OutputDirectory           string
	TypesOnly                 bool

	Associative bool

	Logger *log.Logger
}

func Generate(opts *Options) error {
	lexerFile, err := os.Open(opts.LexerDescriptionFilename)
	if err != nil {
		return fmt.Errorf("could not open lexer description file: %w", err)
	}

	lexerDesc, err := parseLexerDescription(lexerFile, opts.Logger)
	if err != nil {
		return fmt.Errorf("could not parse lexer description: %w", err)
	}

	if err := lexerDesc.compile(); err != nil {
		return fmt.Errorf("could not compile lexer: %w", err)
	}

	if err := lexerFile.Close(); err != nil {
		opts.Logger.Printf("could not close lexer description file: %v\n", err)
	}

	parserFile, err := os.Open(opts.ParserDescriptionFilename)
	if err != nil {
		return fmt.Errorf("could not open parser file: %w", err)
	}

	parserDesc, err := parseParserDescription(parserFile, opts.Logger)
	if err != nil {
		return fmt.Errorf("could not parse parser description: %w", err)
	}

	if err := parserDesc.compile(opts); err != nil {
		return fmt.Errorf("could not compile parser: %w", err)
	}

	if err := parserFile.Close(); err != nil {
		opts.Logger.Printf("could not close parser description file: %v\n", err)
	}

	lexerGenFile, parserGenFile, err := emitFiles(opts.OutputDirectory, opts.TypesOnly, opts.Logger)
	if err != nil {
		return fmt.Errorf("could not generate output files: %w", err)
	}
	defer lexerGenFile.Close()
	defer parserGenFile.Close()

	lexerDesc.emit(lexerGenFile, opts)
	parserDesc.emit(parserGenFile, opts)

	return nil
}

func emitFiles(outdir string, typesOnly bool, logger *log.Logger) (*os.File, *os.File, error) {
	s, err := os.Stat(outdir)
	if err != nil {
		if os.IsNotExist(err) {
			logger.Printf("Creating directory %s...\n", outdir)
			if err = os.Mkdir(outdir, os.ModeDir); err != nil {
				return nil, nil, fmt.Errorf("could not create output directory %s: %w", outdir, err)
			}
		}

		return nil, nil, err
	}
	if !s.IsDir() {
		return nil, nil, fmt.Errorf("%s is not a directory", outdir)
	}

	packageName := "main"
	if typesOnly {
		packageName = s.Name()
	}

	lPath := path.Join(outdir, GeneratedLexerFilename)

	logger.Printf("Creating lexer file %s...\n", lPath)

	lFile, err := os.Create(lPath)
	if err != nil {
		return nil, nil, fmt.Errorf("could not create lexer file %s: %w", lPath, err)
	}

	fmt.Fprintf(lFile, "// Code generated by Gopapageno; DO NOT EDIT.\n")
	fmt.Fprintf(lFile, "package %s\n\n", packageName)
	fmt.Fprintf(lFile, "import \"github.com/giornetta/gopapageno\"\n\n")

	pPath := path.Join(outdir, GeneratedParserFilename)

	logger.Printf("Creating parser file %s...\n", lPath)

	pFile, err := os.Create(pPath)
	if err != nil {
		return nil, nil, fmt.Errorf("could not create parser file %s: %w", lPath, err)
	}

	fmt.Fprintf(pFile, "// Code generated by Gopapageno; DO NOT EDIT.\n")
	fmt.Fprintf(pFile, "package %s\n\n", packageName)
	fmt.Fprintf(pFile, "import \"github.com/giornetta/gopapageno\"\n\n")

	if typesOnly {
		return lFile, pFile, nil
	}

	mainPath := path.Join(outdir, GeneratedMainFilename)

	logger.Printf("Creating main file %s...\n", mainPath)

	mainFile, err := os.Create(mainPath)
	if err != nil {
		return nil, nil, fmt.Errorf("could not create main file %s: %w", mainPath, err)
	}

	fmt.Fprintf(mainFile, "// Code generated by Gopapageno.\n")
	fmt.Fprintf(mainFile, "package %s\n", packageName)
	fmt.Fprintf(mainFile, `
import (
	"context"
	"flag"
	"fmt"
	"github.com/giornetta/gopapageno"
	"io"
	"log"
	"os"
	"time"
)

func main() {
	start := time.Now()

	if err := run(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	fmt.Println(time.Since(start))
}

func run() error {
	sourceFlag := flag.String("f", "", "source file")
	concurrencyFlag := flag.Int("c", 1, "number of concurrent goroutines to spawn")
	logFlag := flag.Bool("log", false, "enable logging")

	cpuProfileFlag := flag.String("cpuprof", "", "output file for CPU profiling")
	memProfileFlag := flag.String("memprof", "", "output file for Memory profiling")

	flag.Parse()

	bytes, err := os.ReadFile(*sourceFlag)
	if err != nil {
		return fmt.Errorf("could not read source file %%s: %%w", *sourceFlag, err)
	}

	logOut := io.Discard
	if *logFlag {
		logOut = os.Stderr
	}

	cpuProfileWriter := io.Discard
	if *cpuProfileFlag != "" {
		cpuProfileWriter, err = os.Create(*cpuProfileFlag)
		if err != nil {
			cpuProfileWriter = io.Discard
		}
	}

	memProfileWriter := io.Discard
	if *memProfileFlag != "" {
		memProfileWriter, err = os.Create(*memProfileFlag)
		if err != nil {
			memProfileWriter = io.Discard
		}
	}

	p := NewParser(
		gopapageno.WithConcurrency(*concurrencyFlag),
		gopapageno.WithLogging(log.New(logOut, "", 0)),
		gopapageno.WithCPUProfiling(cpuProfileWriter),
		gopapageno.WithMemoryProfiling(memProfileWriter),
		gopapageno.WithPreallocFunc(ParserPreallocMem))

	ctx := context.Background()

	root, err := p.Parse(ctx, bytes)
	if err != nil {
		return fmt.Errorf("could not parse source: %%w", err)
	}

	_ = root

	return nil
}
`)

	if err := mainFile.Close(); err != nil {
		logger.Printf("Could not close main file: %v\n", err)
	}

	return lFile, pFile, nil
}
